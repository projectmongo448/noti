(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("@aspnet/signalr"));
	else if(typeof define === 'function' && define.amd)
		define(["vue", "@aspnet/signalr"], factory);
	else if(typeof exports === 'object')
		exports["dotnetify"] = factory(require("vue"), require("@aspnet/signalr"));
	else
		root["dotnetify"] = factory(root["Vue"], root["signalR"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__15__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 23);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch = exports.createEventEmitter = void 0;
var Utils = (function () {
    function Utils() {
    }
    Utils.prototype.trim = function (iStr) {
        if (typeof iStr !== "string")
            return "";
        while (iStr.indexOf("/", iStr.length - 1) >= 0)
            iStr = iStr.substr(0, iStr.length - 1);
        while (iStr.indexOf("/") == 0)
            iStr = iStr.substr(1, iStr.length - 1);
        return iStr;
    };
    Utils.prototype.equal = function (iStr1, iStr2) {
        return (iStr1 != null &&
            iStr2 != null &&
            iStr1.toLowerCase() == iStr2.toLowerCase());
    };
    Utils.prototype.startsWith = function (iStr, iValue) {
        return iStr.toLowerCase().slice(0, iValue.length) == iValue.toLowerCase();
    };
    Utils.prototype.endsWith = function (iStr, iValue) {
        return (iValue == "" ||
            iStr.toLowerCase().slice(-iValue.length) == iValue.toLowerCase());
    };
    Utils.prototype.dispatchEvent = function (iEvent) {
        if (typeof Event === "function")
            dispatchEvent(new Event(iEvent));
        else {
            var event = document.createEvent("CustomEvent");
            event.initEvent(iEvent, true, true);
            dispatchEvent(event);
        }
    };
    Utils.prototype.grep = function (iArray, iFilter) {
        return Array.isArray(iArray) ? iArray.filter(iFilter) : [];
    };
    return Utils;
}());
exports.createEventEmitter = function () {
    var subscribers = [];
    return {
        emit: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var handled = false;
            subscribers.forEach(function (subscriber) {
                handled = subscriber.apply(void 0, args) || handled;
            });
            return handled;
        },
        subscribe: function (subscriber) {
            !subscribers.includes(subscriber) && subscribers.push(subscriber);
            return function () { return (subscribers = subscribers.filter(function (x) { return x !== subscriber; })); };
        }
    };
};
exports.fetch = function (iMethod, iUrl, iData, iOptions) {
    return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open(iMethod, iUrl, true);
        if (typeof iOptions == "function")
            iOptions(request);
        request.onload = function () {
            if (request.status >= 200 && request.status < 400) {
                var response = request.responseText;
                resolve(response);
            }
            else
                reject(request);
        };
        request.onerror = function () {
            reject(request);
        };
        request.send(iData);
    });
};
exports.default = new Utils();


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__1__;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* 
Copyright 2017 Dicky Suryadi

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */

var window = window || global || {};

var jQueryDeferred = __webpack_require__(19);
var jQueryShim = jQueryDeferred.extend(function (selector) {
  if (selector === window || selector.document) return {
    0: selector,
    on: function on(iEvent, iHandler) {
      window.addEventListener(iEvent, iHandler);
    },
    bind: function bind(iEvent, iHandler) {
      window.addEventListener(iEvent, iHandler, false);
    },
    unbind: function unbind(iEvent, iHandler) {
      window.removeEventListener(iEvent, iHandler, false);
    }
  };

  if (typeof selector !== "string") selector.events = selector.events || {};

  return {
    0: selector,

    bind: function bind(iEvent, iHandler) {
      var event = selector.events[iEvent] || [];
      event.push(iHandler);
      selector.events[iEvent] = event;
    },

    unbind: function unbind(iEvent, iHandler) {
      var handlers = selector.events[iEvent] || [];
      if (iHandler) {
        var idx = handlers.indexOf(iHandler);
        if (idx !== -1) handlers.splice(idx, 1);
      } else handlers = [];
      selector.events[iEvent] = handlers;
    },

    triggerHandler: function triggerHandler(iEvent, iArgs) {
      var handlers = selector.events[iEvent] || [];
      var args = [{ type: iEvent }];
      if (Array.isArray(iArgs)) iArgs.forEach(function (arg) {
        args.push(arg);
      });else if (iArgs) args.push(iArgs);
      handlers.forEach(function (handler) {
        handler.apply(this, args);
      });
    },

    load: function load(iUrl, iArgs, iHandler) {
      var request = new window.XMLHttpRequest();
      request.open("GET", iUrl, true);
      request.onload = function () {
        if (request.status >= 200 && request.status < 400) {
          var response = request.responseText;
          document.querySelector(selector).innerHTML = response;
          iHandler.call(document.querySelector(selector));
        }
      };
      request.send();
      return {
        abort: function abort(reason) {
          return request.abort(reason);
        }
      };
    }
  };
}, jQueryDeferred, {
  support: { cors: true },

  trim: function trim(iStr) {
    return typeof iStr === "string" ? iStr.trim() : iStr;
  },

  inArray: function inArray(iArray, iItem) {
    return iArray.indexOf(iItem) !== -1;
  },

  makeArray: function makeArray(iArray) {
    return [].slice.call(iArray, 0);
  },

  merge: function merge(iArray1, iArray2) {
    Array.prototype.push.apply(iArray1, iArray2);
    return iArray1;
  },

  isEmptyObject: function isEmptyObject(iObj) {
    return !iObj || Object.keys(iObj).length === 0;
  },

  ajax: function ajax(iOptions) {
    var request = new window.XMLHttpRequest();
    request.onreadystatechange = function () {
      if (request.readyState !== 4) return;
      if (request.status === 200 && !request._hasError) {
        try {
          iOptions.success && iOptions.success(JSON.parse(request.responseText));
        } catch (error) {
          iOptions.success && iOptions.success(request.responseText);
        }
      } else iOptions.error && iOptions.error(request);
    };
    request.open(iOptions.type, iOptions.url);
    request.setRequestHeader("content-type", iOptions.contentType);
    request.send(iOptions.data.data && "data=" + iOptions.data.data);
    return {
      abort: function abort(reason) {
        return request.abort(reason);
      }
    };
  },

  getScript: function getScript(iUrl, iSuccess) {
    var done = false;
    var promise = jQueryDeferred.Deferred();
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.src = iUrl;
    script.onload = script.onreadystatechange = function () {
      if (!done && (!this.readyState || this.readyState == "loaded" || this.readyState == "complete")) {
        done = true;
        script.onload = script.onreadystatechange = null;
        head.removeChild(script);
        if (typeof iSuccess === "function") iSuccess();
        promise.resolve();
      }
    };
    head.appendChild(script);
    return promise;
  }
});

if (typeof window !== "undefined") window.jQuery = window.jQuery || jQueryShim;

if (( false ? undefined : _typeof(exports)) === "object" && ( false ? undefined : _typeof(module)) === "object") module.exports = jQueryShim;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2), __webpack_require__(20)(module)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotnetifyVue = void 0;
var vue_1 = __webpack_require__(1);
var vue_2 = __webpack_require__(1);
var dotnetify_1 = __webpack_require__(22);
var dotnetify_vm_1 = __webpack_require__(12);
var _window = window || global || {};
var dotnetify = _window.dotnetify || dotnetify_1.default;
var DotnetifyVue = (function () {
    function DotnetifyVue() {
        this.version = "3.0.0";
        this.viewModels = {};
        this.plugins = {};
        this.controller = dotnetify;
        this._hubs = [];
    }
    DotnetifyVue.prototype.init = function (iHub) {
        var _this = this;
        var hubInitialized = this._hubs.some(function (hub) { return hub === iHub; });
        var start = function () {
            if (!iHub.isHubStarted)
                Object.keys(_this.viewModels)
                    .filter(function (vmId) { return _this.viewModels[vmId].$hub === iHub; })
                    .forEach(function (vmId) { return (_this.viewModels[vmId].$requested = false); });
            dotnetify.startHub(iHub);
        };
        if (!hubInitialized) {
            iHub.responseEvent.subscribe(function (iVMId, iVMData) { return _this._responseVM(iVMId, iVMData); });
            iHub.connectedEvent.subscribe(function () {
                return Object.keys(_this.viewModels)
                    .filter(function (vmId) { return _this.viewModels[vmId].$hub === iHub && !_this.viewModels[vmId].$requested; })
                    .forEach(function (vmId) { return _this.viewModels[vmId].$request(); });
            });
            iHub.reconnectedEvent.subscribe(start);
            this._hubs.push(iHub);
        }
        start();
    };
    DotnetifyVue.prototype.connect = function (iVMId, iVue, iOptions) {
        if (this.viewModels.hasOwnProperty(iVMId)) {
            console.error("Component is attempting to connect to an already active '" + iVMId + "'. " +
                " If it's from a dismounted component, you must call vm.$destroy on unmount.");
            this.viewModels[iVMId].$destroy();
        }
        var self = this;
        var component = {
            get props() {
                return iVue.$props;
            },
            get state() {
                var vm = self.viewModels[iVMId];
                return vm && vm["$useState"] ? __assign(__assign({}, iVue.$data), iVue.state) : iVue.$data;
            },
            setState: function (state) {
                Object.keys(state).forEach(function (key) {
                    var value = state[key];
                    var vm = self.viewModels[iVMId];
                    if (vm && vm["$useState"]) {
                        if (iVue.state.hasOwnProperty(key))
                            iVue.state[key] = value;
                        else if (value)
                            self._vueSetState(iVue, key, value);
                    }
                    else {
                        if (self._vueHasProperty(iVue, key))
                            iVue[key] = value;
                        else if (value)
                            console.error("'" + key + "' is received, but the Vue instance doesn't declare the property.");
                    }
                });
            }
        };
        var connectInfo = dotnetify.selectHub({
            vmId: iVMId,
            options: iOptions,
            hub: null
        });
        this.viewModels[iVMId] = new dotnetify_vm_1.default(connectInfo.vmId, component, connectInfo.options, this, connectInfo.hub);
        if (connectInfo.hub)
            this.init(connectInfo.hub);
        if (iOptions) {
            var vm = this.viewModels[iVMId];
            if (iOptions.useState) {
                if (this._vueHasProperty(iVue, "state"))
                    vm["$useState"] = true;
                else
                    console.error("Option 'useState' requires the 'state' data property on the Vue instance.");
            }
            if (Array.isArray(iOptions.watch))
                this._addWatchers(iOptions.watch, vm, iVue);
        }
        return this.viewModels[iVMId];
    };
    DotnetifyVue.prototype.component = function (iComponentOrName, iVMId, iOptions) {
        var obj = {
            vm: null,
            created: function () {
                this.vm = dotnetify.vue.connect(iVMId, this, __assign(__assign({}, iOptions), { useState: true }));
            },
            unmounted: function () {
                this.vm.$destroy();
            },
            data: function () {
                return { state: {} };
            }
        };
        this._vueAddUnmounted(obj);
        if (typeof iComponentOrName == "string")
            return __assign({ name: iComponentOrName }, obj);
        else
            return __assign(__assign({}, obj), iComponentOrName);
    };
    DotnetifyVue.prototype.getViewModels = function () {
        var self = dotnetify.vue;
        return Object.keys(self.viewModels).map(function (vmId) { return self.viewModels[vmId]; });
    };
    DotnetifyVue.prototype._addWatchers = function (iWatchlist, iVM, iVue) {
        var callback = function (prop) {
            return function (newValue) {
                var _a;
                iVM.$serverUpdate !== false && iVM.$dispatch((_a = {}, _a[prop] = newValue, _a));
            }.bind(iVM);
        };
        var useState = iVM["$useState"];
        if (vue_2.watch) {
            iWatchlist.forEach(function (prop) { return vue_2.watch(function () { return (useState ? iVue.state[prop] : iVue[prop]); }, callback(prop)); });
        }
        else {
            iWatchlist.forEach(function (prop) { return iVue.$watch(useState ? "state." + prop : prop, callback(prop)); });
        }
    };
    DotnetifyVue.prototype._responseVM = function (iVMId, iVMData) {
        var self = dotnetify.vue;
        if (self.viewModels.hasOwnProperty(iVMId)) {
            var vm_1 = self.viewModels[iVMId];
            dotnetify.checkServerSideException(iVMId, iVMData, vm_1.$exceptionHandler);
            vm_1.$serverUpdate = false;
            vm_1.$update(iVMData);
            setTimeout(function () { return (vm_1.$serverUpdate = true); });
            return true;
        }
        return false;
    };
    DotnetifyVue.prototype._vueHasProperty = function (iVue, iKey) {
        if (iVue) {
            if (typeof iVue.hasOwnProperty === "function")
                return iVue.hasOwnProperty(iKey);
            else
                return typeof iVue[iKey] !== "undefined";
        }
        return false;
    };
    DotnetifyVue.prototype._vueSetState = function (iVue, iKey, iValue) {
        if (iVue) {
            if (typeof iVue.$set === "function")
                iVue.$set(iVue.state, iKey, iValue);
            else
                iVue.state[iKey] = iValue;
        }
    };
    DotnetifyVue.prototype._vueAddUnmounted = function (iVue) {
        var vmDestroyFunc = function () {
            this.vm.$destroy();
        };
        if (vue_1.default && vue_1.default.directive)
            Object.assign(iVue, { destroyed: vmDestroyFunc });
        else
            Object.assign(iVue, { unmounted: vmDestroyFunc });
    };
    return DotnetifyVue;
}());
exports.DotnetifyVue = DotnetifyVue;
dotnetify.vue = new DotnetifyVue();
dotnetify.addVMAccessor(dotnetify.vue.getViewModels);
exports.default = dotnetify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerDirectives = registerDirectives;

var _vue = __webpack_require__(1);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Vue 2.x
if (_vue2.default && _vue2.default.directive) {
  // Call a method when a property value changes.
  _vue2.default.directive("vmOn", {
    bind: function bind(el, binding, vnode) {
      // Parse the value, which should be in object literal { property: fnName }.
      var match = /{(.*):(.*)}/.exec(binding.expression);
      if (match != null) {
        var propName = match[1].trim();
        var methodName = match[2].trim();
        var vue = vnode.context;

        if (!vue.hasOwnProperty(propName)) throw new Error("v-vmOn property '" + propName + "' is not defined");

        if (!vue.hasOwnProperty(methodName) && typeof vue[methodName] == "function") throw new Error("v-vmOn method '" + propName + "' is not defined or not a function");

        vue.$watch(propName, function () {
          return vue[methodName](el);
        });
      }
    }
  });

  // Route link directive for anchor tags.
  _vue2.default.directive("vmRoute", {
    bind: function bind(el, binding, vnode) {
      var vue = vnode.context;
      var route = binding.value;
      el.href = route && vue.vm ? vue.vm.$route(route) : "";
      el.addEventListener("click", function (e) {
        e.preventDefault();
        vue.vm.$handleRoute(e);
      });
    },
    componentUpdated: function componentUpdated(el, binding, vnode) {
      var vue = vnode.context;
      var route = binding.value;
      if (route && vue.vm) el.href = vue.vm.$route(route);
    }
  });
}

// Vue 3.x
/* 
Copyright 2018-2021 Dicky Suryadi

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
function registerDirectives(app) {
  app.directive("vmOn", {
    beforeMount: function beforeMount(el, binding, vnode) {
      if (binding.value != null) {
        var propName = Object.keys(binding.value)[0];
        var method = binding.value[propName];
        var vue = binding.instance;

        if (typeof vue[propName] === "undefined") throw new Error("v-vmOn property '" + propName + "' is not defined");

        if (typeof method !== "function") throw new Error("v-vmOn method '" + propName + "' is not defined or not a function");

        vue.$watch(propName, function () {
          return method(el);
        });
      }
    }
  });
  app.directive("vmRoute", {
    beforeMount: function beforeMount(el, binding) {
      var vue = binding.instance;
      var route = binding.value;
      el.href = route && vue.vm ? vue.vm.$route(route) : "";
      el.addEventListener("click", function (e) {
        e.preventDefault();
        vue.vm.$handleRoute(e);
      });
    },
    updated: function updated(el, binding) {
      var vue = binding.instance;
      var route = binding.value;
      if (route && vue.vm) el.href = vue.vm.$route(route);
    }
  });
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dotnetifyVue = __webpack_require__(4);

var _dotnetifyVue2 = _interopRequireDefault(_dotnetifyVue);

var _vue = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* 
Copyright 2018-2021 Dicky Suryadi

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
exports.default = {
  name: "Scope",
  props: {
    vm: String,
    tag: String
  },
  inject: { scoped: { name: "scoped", default: null } },
  provide: function provide() {
    var _this = this;
    return {
      scoped: function scoped(vmId) {
        return _this.getScope(vmId);
      },
      connect: function connect(vmId, component, options) {
        vmId = _this.getScope(vmId);
        return _dotnetifyVue2.default.vue.connect(vmId, component, options);
      }
    };
  },
  render: function render(createElement) {
    return typeof _vue.h === "function" ? (0, _vue.h)(this.tag || "div", null, this.$slots.default()) // Vue 3.x
    : createElement(this.tag || "div", null, this.$slots.default); // Vue 2.x
  },
  methods: {
    getScope: function getScope(vmId) {
      var scope = this.scoped ? this.scoped(this.vm) : this.vm;
      return scope ? scope + "." + vmId : vmId;
    }
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
var $ = __webpack_require__(3);
var DotnetifyVMRouter = (function () {
    function DotnetifyVMRouter(vm, router) {
        this.routes = [];
        this.vm = vm;
        this.router = router;
        this.debug = vm.$dotnetify.controller.debug;
        router.resetUrlOnReconnected(this.vm.$hub);
        if (vm.$options && vm.$options.onRouteEnter)
            vm["onRouteEnter"] = vm.$options.onRouteEnter;
    }
    Object.defineProperty(DotnetifyVMRouter.prototype, "hasRoutingState", {
        get: function () {
            throw new Error("Not implemented");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVMRouter.prototype, "RoutingState", {
        get: function () {
            throw new Error("Not implemented");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVMRouter.prototype, "VMRoot", {
        get: function () {
            throw new Error("Not implemented");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVMRouter.prototype, "VMArg", {
        get: function () {
            throw new Error("Not implemented");
        },
        enumerable: false,
        configurable: true
    });
    DotnetifyVMRouter.prototype.dispatchActiveRoutingState = function (iPath) {
        this.vm.$dispatch({ "RoutingState.Active": iPath });
        var RoutingState = this.vm.State().RoutingState;
        RoutingState = Object.assign(RoutingState || {}, { Active: iPath });
        this.vm.State({ RoutingState: RoutingState });
    };
    DotnetifyVMRouter.prototype.handleRoute = function (iArg) {
        var _this = this;
        var path = null;
        if (typeof iArg === "object") {
            iArg.preventDefault();
            path = iArg.currentTarget.pathname;
        }
        else if (typeof iArg === "string")
            path = iArg;
        if (path == null || path == "")
            throw new Error("$handleRoute requires path argument or event with pathname.");
        setTimeout(function () { return _this.router.pushState({}, "", path); });
    };
    DotnetifyVMRouter.prototype.initRoot = function () {
        if (!this.hasRoutingState || this.RoutingState === null || this.RoutingState.Root === null)
            return;
        if (this._absRoot != this.RoutingState.Root) {
            var absRoot = utils_1.default.trim(this.VMRoot);
            if (absRoot != "")
                absRoot = "/" + absRoot;
            var root = utils_1.default.trim(this.RoutingState.Root);
            this._absRoot = root != "" ? absRoot + "/" + root : absRoot;
            this.RoutingState.Root = this._absRoot;
        }
    };
    DotnetifyVMRouter.prototype.initRouting = function () {
        var _this = this;
        var vm = this.vm;
        if (!this.hasRoutingState) {
            if (this.router.urlPath)
                this.raiseRoutedEvent(true);
            return;
        }
        if (this.RoutingState === null) {
            console.error("router> the RoutingState prop of '" + vm.$vmId + "' was not initialized.");
            return;
        }
        var templates = this.RoutingState.Templates;
        if (templates == null || templates.length == 0)
            return;
        if (!this.router._init) {
            this.router.init();
            this.router._init = true;
        }
        this.initRoot();
        templates.forEach(function (template) {
            var urlPattern = template.UrlPattern != null ? template.UrlPattern : template.Id;
            urlPattern = urlPattern != "" ? urlPattern : "/";
            var mapUrl = _this.toUrl(urlPattern);
            if (_this.debug)
                console.log("router> map " + mapUrl + " to template id=" + template.Id);
            _this.router.mapTo(mapUrl, function (iParams) {
                _this.router.urlPath = "";
                var path = urlPattern;
                for (var param in iParams)
                    path = path.replace(":" + param, iParams[param]);
                path = path.replace(/\(\/:([^)]+)\)/g, "").replace(/\(|\)/g, "");
                _this.routeTo(path, template);
            });
        });
        var activeUrl = this.toUrl(this.RoutingState.Active);
        if (this.router.urlPath == "")
            this.router.urlPath = activeUrl;
        if (!this.routeUrl())
            this.raiseRoutedEvent(true);
    };
    DotnetifyVMRouter.prototype.isActive = function (iRoute) {
        if (iRoute != null && iRoute.hasOwnProperty("Path")) {
            return utils_1.default.equal(iRoute.Path, this.RoutingState.Active);
        }
        return false;
    };
    DotnetifyVMRouter.prototype.loadHtmlView = function (iTargetSelector, iViewUrl, iJsModuleUrl, iCallbackFn) {
        var vm = this.vm;
        this.unmountView(iTargetSelector);
        $(iTargetSelector).load(iViewUrl, null, function () {
            if (iJsModuleUrl != null) {
                var getScripts = iJsModuleUrl.split(",").map(function (i) { return $.getScript(i); });
                $.when.apply($, getScripts).done(function () { return typeof iCallbackFn === "function" && iCallbackFn.call(vm); });
            }
            else if (typeof iCallbackFn === "function")
                iCallbackFn.call(vm);
        });
    };
    DotnetifyVMRouter.prototype.loadHtmlElementView = function (iTargetSelector, iHtmlElement, iJsModuleUrl, iVmArg, iCallbackFn) {
        var _this = this;
        var vm = this.vm;
        var mountViewFunc = function () {
            _this.unmountView(iTargetSelector);
            var target = document.querySelector(iTargetSelector);
            while (target.firstChild)
                target.removeChild(target.firstChild);
            target.appendChild(iHtmlElement);
            if (typeof iCallbackFn === "function")
                iCallbackFn.call(vm);
        };
        if (iJsModuleUrl == null)
            mountViewFunc();
        else {
            var getScripts = iJsModuleUrl.split(",").map(function (i) { return $.getScript(i); });
            $.when.apply($, getScripts).done(mountViewFunc);
        }
    };
    DotnetifyVMRouter.prototype.loadView = function (iTargetSelector, iViewUrl, iJsModuleUrl, iVmArg, iCallbackFn) {
        throw new Error("Not implemented");
    };
    DotnetifyVMRouter.prototype.manualRouteTo = function (iPath, iTarget, iViewUrl, iJSModuleUrl) {
        var vm = this.vm;
        var template = {
            Id: "manual",
            UrlPattern: null,
            Target: iTarget,
            ViewUrl: iViewUrl,
            JSModuleUrl: iJSModuleUrl
        };
        this.routeTo(iPath, template, true);
    };
    DotnetifyVMRouter.prototype.onRouteEnter = function (iPath, iTemplate) {
        return true;
    };
    DotnetifyVMRouter.prototype.raiseRoutedEvent = function (noMatch) {
        var _this = this;
        if (this.RoutingState && this.RoutingState.Templates) {
            if (noMatch) {
                var noMatchTemplate = this.RoutingState.Templates.find(function (x) { return x.UrlPattern === "*"; });
                if (noMatchTemplate)
                    this.routeTo(this.router.urlPath, noMatchTemplate);
                else if (this.router.notFound404Url)
                    setTimeout(function () { return (window.location.href = _this.router.notFound404Url); });
            }
            if (this.debug)
                console.log("router> routed" + (noMatch ? " (404)" : ""));
        }
        this.router.routedEvent.emit();
    };
    DotnetifyVMRouter.prototype.route = function (iRoute, iTarget) {
        if (iRoute == null)
            return;
        if (!iRoute.hasOwnProperty("Path") && !iRoute.hasOwnProperty("TemplateId"))
            throw new Error("Not a valid route");
        this.initRoot();
        var path = iRoute.Path;
        var template = null;
        if (this.hasRoutingState && this.RoutingState.Templates != null && iRoute.TemplateId != null) {
            var match = this.RoutingState.Templates.filter(function (iTemplate) {
                return iTemplate.Id == iRoute.TemplateId;
            });
            if (match.length > 0) {
                template = match[0];
                if (typeof iTarget === "string")
                    template.Target = iTarget;
                if (path == null) {
                    path = template.UrlPattern != null ? template.UrlPattern : template.Id;
                    iRoute.Path = path;
                }
            }
            else if (iRoute.RedirectRoot == null)
                throw new Error("vmRoute cannot find route template " + iRoute.TemplateId);
        }
        if (iRoute.RedirectRoot != null) {
            var redirectRoot = iRoute.RedirectRoot;
            if (redirectRoot.charAt(0) == "/")
                redirectRoot = redirectRoot.substr(0, redirectRoot.length - 1);
            var redirectRootPath = iRoute.RedirectRoot.split("/");
            var urlRedirect = "";
            var absRoot = this.VMRoot;
            if (absRoot != null) {
                var absRootPath = absRoot.split("/");
                for (var i = 0; i < absRootPath.length; i++) {
                    if (absRootPath[i] != "" && absRootPath[i] == redirectRootPath[0])
                        break;
                    urlRedirect += absRootPath[i] + "/";
                }
            }
            urlRedirect += redirectRoot + "/" + path;
            urlRedirect = urlRedirect.replace(/\/\/+/g, "/");
            if (!this.routes.some(function (x) { return x.Path === path; }))
                this.routes.push({ TemplateId: null, Path: path, Url: urlRedirect });
            return urlRedirect;
        }
        if (template == null)
            throw new Error("vmRoute cannot find any route template");
        iRoute["$template"] = template;
        this.pathToRoute = this.pathToRoute || {};
        this.pathToRoute[path] = iRoute;
        var url = this.toUrl(path);
        url = url.length > 0 ? url : "/";
        if (!this.routes.some(function (x) { return x.Path === path; }))
            this.routes.push({ TemplateId: null, Path: path, Url: url });
        return url;
    };
    DotnetifyVMRouter.prototype.routeTo = function (iPath, iTemplate, iDisableEvent, iCallbackFn, isRedirect) {
        var _this = this;
        var vm = this.vm;
        var viewModels = vm.$dotnetify.getViewModels();
        if (this.debug)
            console.log("router> route '" + iPath + "' to template id=" + iTemplate.Id);
        var pathUrl = this.toUrl(iPath);
        for (var i = 0; i < viewModels.length; i++) {
            var vmOther = viewModels[i];
            var vmArg = vmOther["$router"].VMArg;
            if (vmArg != null) {
                if (typeof vmArg["RoutingState.Origin"] === "string" && utils_1.default.equal(vmArg["RoutingState.Origin"], pathUrl))
                    return;
            }
        }
        var activateRoute = function () {
            if (iTemplate.Target == null) {
                console.error("router> the Target for template '" + iTemplate.Id + "' was not set.  Use vm.onRouteEnter() to set the target.");
                return;
            }
            if (document.getElementById(iTemplate.Target) == null) {
                if (isRedirect === true) {
                    if (_this.debug)
                        console.log("router> target '" + iTemplate.Target + "' not found in DOM");
                    return;
                }
                else {
                    if (_this.debug)
                        console.log("router> target '" + iTemplate.Target + "' not found in DOM, use redirect instead");
                    return _this.router.redirect(_this.toUrl(iPath), __spreadArrays(viewModels, vm.$dotnetify.controller.getViewModels()));
                }
            }
            _this.loadView("#" + iTemplate.Target, iTemplate.ViewUrl, iTemplate.JSModuleUrl, { "RoutingState.Origin": iPath }, function () {
                _this.dispatchActiveRoutingState(iPath);
                if (iDisableEvent != true && vm.hasOwnProperty("onRouteExit"))
                    vm["onRouteExit"](iPath, iTemplate);
                if (typeof iCallbackFn === "function")
                    iCallbackFn.call(vm);
            });
        };
        if (iDisableEvent != true && vm.hasOwnProperty("onRouteEnter")) {
            if (this.onRouteEnter(iPath, iTemplate) === false)
                return;
            var result = vm.onRouteEnter(iPath, iTemplate);
            if (result === false)
                return;
            else if (result && typeof result.then == "function") {
                result.then(function (res) { return res !== false && activateRoute(); });
                return;
            }
        }
        activateRoute();
    };
    DotnetifyVMRouter.prototype.routeToRoute = function (iRoute) {
        var _this = this;
        var path = this.vm["$route"](iRoute);
        if (path == null || path == "")
            throw new Error("The route passed to $routeTo is invalid.");
        setTimeout(function () { return _this.router.pushState({}, "", path); });
    };
    DotnetifyVMRouter.prototype.routeUrl = function (redirectUrlPath) {
        var _this = this;
        if (!this.hasRoutingState)
            return false;
        var isRedirect = !!redirectUrlPath;
        var root = this.RoutingState.Root;
        if (root == null)
            return false;
        var urlPath = isRedirect ? redirectUrlPath : this.router.urlPath;
        if (this.debug)
            console.log("router> routing " + urlPath);
        if (utils_1.default.equal(urlPath, root) || utils_1.default.equal(urlPath, root + "/") || urlPath === "/") {
            var match = utils_1.default.grep(this.RoutingState.Templates, function (iTemplate) {
                return iTemplate.UrlPattern === "";
            });
            if (match.length > 0) {
                this.routeTo("", match[0], null, null, isRedirect);
                this.router.urlPath = "";
                this.raiseRoutedEvent();
                return true;
            }
            return false;
        }
        root = root + "/";
        if (utils_1.default.startsWith(urlPath, root)) {
            var routeElem = null;
            var match = utils_1.default.grep(this.routes, function (elem) {
                return utils_1.default.startsWith(urlPath + "/", elem.Url + "/");
            });
            if (match.length > 0) {
                for (var i = 0; i < match.length; i++)
                    if (routeElem == null || routeElem.Url.length < match[i].Url.length)
                        routeElem = match[i];
            }
            if (routeElem != null) {
                var path = routeElem.Path;
                var template = this.hasOwnProperty("pathToRoute") && this.pathToRoute.hasOwnProperty(path) ? this.pathToRoute[path].$template : null;
                if (template != null) {
                    if (utils_1.default.equal(this.router.urlPath, this.toUrl(path)))
                        this.router.urlPath = "";
                    if (!utils_1.default.equal(this.RoutingState.Active, path)) {
                        this.routeTo(path, template, false, function () { return _this.raiseRoutedEvent(); }, isRedirect);
                    }
                    else
                        this.raiseRoutedEvent();
                    return true;
                }
            }
            else if (this.router.match(urlPath)) {
                this.router.urlPath = "";
                this.raiseRoutedEvent();
                return true;
            }
        }
        return false;
    };
    DotnetifyVMRouter.prototype.toUrl = function (iPath) {
        var path = utils_1.default.trim(iPath);
        if (path.charAt(0) != "(" && path != "")
            path = "/" + path;
        return this.hasRoutingState ? this.RoutingState.Root + path : iPath;
    };
    DotnetifyVMRouter.prototype.unmountView = function (iTargetSelector) {
        throw new Error("Not implemented");
    };
    return DotnetifyVMRouter;
}());
exports.default = DotnetifyVMRouter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var vue_1 = __webpack_require__(1);
var vue_2 = __webpack_require__(1);
var dotnetify_vm_router_1 = __webpack_require__(7);
var directives_1 = __webpack_require__(5);
var utils_1 = __webpack_require__(0);
var $ = __webpack_require__(3);
var _window = window || global || {};
var DotnetifyVueVMRouter = (function (_super) {
    __extends(DotnetifyVueVMRouter, _super);
    function DotnetifyVueVMRouter(iVM, iDotNetifyRouter) {
        return _super.call(this, iVM, iDotNetifyRouter) || this;
    }
    Object.defineProperty(DotnetifyVueVMRouter.prototype, "hasRoutingState", {
        get: function () {
            var state = this.vm.State();
            return state && state.hasOwnProperty("RoutingState");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVueVMRouter.prototype, "RoutingState", {
        get: function () {
            return this.vm.State().RoutingState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVueVMRouter.prototype, "VMRoot", {
        get: function () {
            return this.vm.Props("vmRoot");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DotnetifyVueVMRouter.prototype, "VMArg", {
        get: function () {
            return this.vm.Props("vmArg");
        },
        enumerable: false,
        configurable: true
    });
    DotnetifyVueVMRouter.prototype.onRouteEnter = function (iPath, iTemplate) {
        if (!iTemplate.ViewUrl)
            iTemplate.ViewUrl = iTemplate.Id;
        return true;
    };
    DotnetifyVueVMRouter.prototype.loadView = function (iTargetSelector, iViewUrl, iJsModuleUrl, iVmArg, iCallbackFn) {
        var vm = this.vm;
        var componentProps;
        if (this.hasRoutingState) {
            if (this.RoutingState === null) {
                console.error("router> the RoutingState prop of '" + vm.$vmId + "' was not initialized.");
                return;
            }
            var root = this.VMRoot;
            root = root != null ? "/" + utils_1.default.trim(this.RoutingState.Root) + "/" + utils_1.default.trim(root) : this.RoutingState.Root;
            componentProps = { vmRoot: root, vmArg: iVmArg };
        }
        iViewUrl = this.router.overrideUrl(iViewUrl, iTargetSelector);
        iJsModuleUrl = this.router.overrideUrl(iJsModuleUrl, iTargetSelector);
        if (utils_1.default.endsWith(iViewUrl, "html"))
            this.loadHtmlView(iTargetSelector, iViewUrl, iJsModuleUrl, iCallbackFn);
        else {
            var component = iViewUrl;
            if (typeof iViewUrl === "string" && _window.hasOwnProperty(iViewUrl))
                component = Object.assign({}, _window[iViewUrl]);
            if (component instanceof HTMLElement)
                this.loadHtmlElementView(iTargetSelector, component, iJsModuleUrl, componentProps, iCallbackFn);
            else
                this.loadVueView(iTargetSelector, component, iJsModuleUrl, componentProps, iCallbackFn);
        }
    };
    DotnetifyVueVMRouter.prototype.loadVueView = function (iTargetSelector, iComponent, iJsModuleUrl, iProps, iCallbackFn) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var vm = _this.vm;
            var vmId = _this.vm ? _this.vm.$vmId : "";
            var createViewFunc = function () {
                var vueClass = iComponent;
                if (typeof iComponent !== "object" || (typeof iComponent.render !== "function" && !iComponent.template)) {
                    console.error("[" + vmId + "] failed to load view '" + iComponent + "' because it's not a Vue element.");
                    reject();
                    return;
                }
                _this.unmountView(iTargetSelector);
                var data = typeof vueClass.data == "function" ? vueClass.data() : vueClass.data || {};
                if (!data.hasOwnProperty("RoutingState")) {
                    data.RoutingState = {};
                    vueClass.data = function () {
                        return data;
                    };
                }
                if (iProps) {
                    vueClass.props = vueClass.props || {};
                    for (var prop in iProps)
                        if (!vueClass.props.hasOwnProperty(prop))
                            vueClass.props[prop] = { type: null };
                }
                document.querySelector(iTargetSelector).innerHTML = "<div />";
                if (vue_2.createApp) {
                    var app_1 = vue_2.createApp(vueClass, iProps);
                    directives_1.registerDirectives(app_1);
                    app_1.mount(iTargetSelector);
                    _this.mountedComponents[iTargetSelector] = function () { return app_1.unmount(); };
                    if (typeof iCallbackFn === "function")
                        iCallbackFn.call(vm, app_1);
                    resolve(app_1);
                }
                else {
                    var vueComponentType = vue_1.default.extend(vueClass);
                    var vueComponent_1 = new vueComponentType({
                        propsData: __assign({}, iProps)
                    });
                    vueComponent_1.$mount(iTargetSelector + " > div");
                    _this.mountedComponents[iTargetSelector] = function () { return vueComponent_1.$destroy(); };
                    if (typeof iCallbackFn === "function")
                        iCallbackFn.call(vm, vueComponent_1);
                    resolve(vueComponent_1);
                }
            };
            if (iJsModuleUrl == null)
                createViewFunc();
            else {
                var getScripts = iJsModuleUrl.split(",").map(function (i) { return $.getScript(i); });
                $.when.apply($, getScripts).done(createViewFunc);
            }
        });
    };
    DotnetifyVueVMRouter.prototype.unmountView = function (iTargetSelector) {
        if (!this.mountedComponents)
            this.mountedComponents = {};
        var unmount = this.mountedComponents[iTargetSelector];
        if (typeof unmount == "function") {
            unmount();
            delete this.mountedComponents[iTargetSelector];
        }
    };
    return DotnetifyVueVMRouter;
}(dotnetify_vm_router_1.default));
exports.default = DotnetifyVueVMRouter;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
PathJS - Copyright (c) 2011 Mike Trpcic, released under the MIT license.
 */
var window = window || global || {};

var Path = {
  // Need this specific version, because latest version is causing issue.
  version: "0.8.5",
  map: function map(path) {
    if (Path.routes.defined.hasOwnProperty(path)) {
      return Path.routes.defined[path];
    } else {
      return new Path.core.route(path);
    }
  },
  root: function root(path) {
    Path.routes.root = path;
  },
  rescue: function rescue(fn) {
    Path.routes.rescue = fn;
  },
  history: {
    initial: {}, // Empty container for "Initial Popstate" checking variables.
    pushState: function pushState(state, title, path) {
      if (Path.history.supported) {
        if (Path.dispatch(path)) {
          history.pushState(state, title, path);
        }
      } else {
        if (Path.history.fallback) {
          window.location.hash = "#" + path;
        }
      }
    },
    popState: function popState(event) {
      var initialPop = !Path.history.initial.popped && location.href == Path.history.initial.URL;
      Path.history.initial.popped = true;
      if (initialPop) return;
      Path.dispatch(document.location.pathname === "/" ? "" : document.location.pathname);
    },
    listen: function listen(fallback) {
      Path.history.supported = !!(window.history && window.history.pushState);
      Path.history.fallback = fallback;

      if (Path.history.supported) {
        Path.history.initial.popped = "state" in window.history, Path.history.initial.URL = location.href;
        window.onpopstate = Path.history.popState;
      } else {
        if (Path.history.fallback) {
          for (route in Path.routes.defined) {
            if (route.charAt(0) != "#") {
              Path.routes.defined["#" + route] = Path.routes.defined[route];
              Path.routes.defined["#" + route].path = "#" + route;
            }
          }
          Path.listen();
        }
      }
    }
  },
  match: function match(path, parameterize) {
    if (path === "") path = "/";
    var params = {},
        route = null,
        possible_routes,
        slice,
        i,
        j,
        compare,
        result;
    for (route in Path.routes.defined) {
      if (route !== null && route !== undefined) {
        route = Path.routes.defined[route];
        possible_routes = route.partition();
        for (j = 0; j < possible_routes.length; j++) {
          slice = possible_routes[j];
          compare = path;
          if (slice.search(/:/) > 0) {
            for (i = 0; i < slice.split("/").length; i++) {
              if (i < compare.split("/").length && slice.split("/")[i].charAt(0) === ":") {
                params[slice.split("/")[i].replace(/:/, "")] = compare.split("/")[i];
                result = compare.split("/");
                result[i] = slice.split("/")[i];
                compare = result.join("/");
              }
            }
          }
          if (slice === compare) {
            if (parameterize) {
              route.params = params;
            }
            return route;
          }
        }
      }
    }
    return null;
  },
  dispatch: function dispatch(passed_route) {
    var previous_route, matched_route;
    if (Path.routes.current !== passed_route) {
      Path.routes.previous = Path.routes.current;
      Path.routes.current = passed_route;
      matched_route = Path.match(passed_route, true);

      if (Path.routes.previous) {
        previous_route = Path.match(Path.routes.previous);
        if (previous_route !== null && previous_route.do_exit !== null) {
          previous_route.do_exit();
        }
      }

      if (matched_route !== null) {
        matched_route.run();
        return true;
      } else {
        if (Path.routes.rescue !== null) {
          Path.routes.rescue();
        }
      }
    }
  },
  listen: function listen() {
    var fn = function fn() {
      Path.dispatch(location.hash);
    };

    if (location.hash === "") {
      if (Path.routes.root !== null) {
        location.hash = Path.routes.root;
      }
    }

    // The 'document.documentMode' checks below ensure that PathJS fires the right events
    // even in IE "Quirks Mode".
    if ("onhashchange" in window && (!document.documentMode || document.documentMode >= 8)) {
      window.onhashchange = fn;
    } else {
      setInterval(fn, 50);
    }

    if (location.hash !== "") {
      Path.dispatch(location.hash);
    }
  },
  core: {
    route: function route(path) {
      this.path = path;
      this.action = null;
      this.do_enter = [];
      this.do_exit = null;
      this.params = {};
      Path.routes.defined[path] = this;
    }
  },
  routes: {
    current: null,
    root: null,
    rescue: null,
    previous: null,
    defined: {}
  }
};

Path.core.route.prototype = {
  to: function to(fn) {
    this.action = fn;
    return this;
  },
  enter: function enter(fns) {
    if (fns instanceof Array) {
      this.do_enter = this.do_enter.concat(fns);
    } else {
      this.do_enter.push(fns);
    }
    return this;
  },
  exit: function exit(fn) {
    this.do_exit = fn;
    return this;
  },
  partition: function partition() {
    var parts = [],
        options = [],
        re = /\(([^}]+?)\)/g,
        text,
        i;
    while (text = re.exec(this.path)) {
      parts.push(text[1]);
    }
    options.push(this.path.split("(")[0]);
    for (i = 0; i < parts.length; i++) {
      options.push(options[options.length - 1] + parts[i]);
    }
    return options;
  },
  run: function run() {
    var halt_execution = false,
        i,
        result,
        previous;

    if (Path.routes.defined[this.path].hasOwnProperty("do_enter")) {
      if (Path.routes.defined[this.path].do_enter.length > 0) {
        for (i = 0; i < Path.routes.defined[this.path].do_enter.length; i++) {
          result = Path.routes.defined[this.path].do_enter[i].apply(this, null);
          if (result === false) {
            halt_execution = true;
            break;
          }
        }
      }
    }
    if (!halt_execution) {
      Path.routes.defined[this.path].action();
    }
  }
};

exports.default = Path;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(0);
var DotnetifyRouter = (function () {
    function DotnetifyRouter(debug) {
        this.version = "3.0.0";
        this.debug = false;
        this.notFound404Url = "/404.html";
        this._init = false;
        this.routedEvent = utils_1.createEventEmitter();
        this.debug = debug;
    }
    Object.defineProperty(DotnetifyRouter.prototype, "urlPath", {
        get: function () {
            return DotnetifyRouter._urlPath;
        },
        set: function (value) {
            DotnetifyRouter._urlPath = value;
        },
        enumerable: false,
        configurable: true
    });
    DotnetifyRouter.prototype.init = function () {
        if (typeof path_1.default !== "undefined") {
            path_1.default.history.listen(true);
            path_1.default.routes.rescue = function () {
            };
        }
        else
            throw new Error("Pathjs library is required for routing.");
    };
    DotnetifyRouter.prototype.mapTo = function (iPath, iFn) {
        iPath = iPath.length > 0 ? iPath : "/";
        if (typeof path_1.default !== "undefined")
            path_1.default.map(iPath).to(function () {
                iFn(this.params);
            });
    };
    DotnetifyRouter.prototype.match = function (iUrlPath) {
        if (typeof path_1.default !== "undefined") {
            var matched = path_1.default.match(iUrlPath, true);
            if (matched != null) {
                matched.run();
                return true;
            }
        }
        return false;
    };
    DotnetifyRouter.prototype.overrideUrl = function (iUrl, iTargetSelector) {
        return iUrl;
    };
    DotnetifyRouter.prototype.pushState = function (iState, iTitle, iPath) {
        this.urlPath = "";
        if (typeof path_1.default !== "undefined")
            path_1.default.history.pushState(iState, iTitle, iPath);
    };
    DotnetifyRouter.prototype.redirect = function (iUrl, viewModels) {
        this.urlPath = iUrl;
        for (var i = 0; i < viewModels.length; i++) {
            var vm = viewModels[i];
            if (vm.$router.routeUrl(iUrl)) {
                if (this.debug)
                    console.log("router> redirected");
                return;
            }
        }
        location.replace(iUrl);
    };
    DotnetifyRouter.prototype.resetUrlOnReconnected = function (iHub) {
        var _this = this;
        var _a;
        if (!this._unsubReconnectedEvent && iHub)
            this._unsubReconnectedEvent = (_a = iHub.reconnectedEvent) === null || _a === void 0 ? void 0 : _a.subscribe(function () { return (_this.urlPath = document.location.pathname); });
    };
    DotnetifyRouter.prototype.$ready = function () {
        this.$router.initRouting();
    };
    DotnetifyRouter.prototype.$update = function (vmData) {
        if (vmData && vmData.RoutingState)
            this.$router.initRouting();
    };
    DotnetifyRouter._urlPath = document.location.pathname;
    return DotnetifyRouter;
}());
exports.default = DotnetifyRouter;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dotnetify_vue_1 = __webpack_require__(4);
var dotnetify_router_1 = __webpack_require__(10);
var dotnetify_vue_vm_router_1 = __webpack_require__(8);
dotnetify_vue_1.default.vue.router = new dotnetify_router_1.default(dotnetify_vue_1.default.debug);
dotnetify_vue_1.default.vue.router.$inject = function (iVM) {
    var router = new dotnetify_vue_vm_router_1.default(iVM, dotnetify_vue_1.default.vue.router);
    iVM.$router = router;
    iVM.$route = function (iRoute, iTarget) { return router.route(iRoute, iTarget); };
    iVM.$handleRoute = function (iEvent) { return router.handleRoute(iEvent); };
    iVM.$routeTo = function (iRoute) { return router.routeToRoute(iRoute); };
};
dotnetify_vue_1.default.vue.router.$mount = function (iTargetSelector, iComponent, iProps, iCallbackFn) {
    return dotnetify_vue_vm_router_1.default.prototype.loadVueView(iTargetSelector, iComponent, null, iProps, iCallbackFn);
};
dotnetify_vue_1.default.vue.plugins["router"] = dotnetify_vue_1.default.vue.router;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var DotnetifyVM = (function () {
    function DotnetifyVM(iVMId, iComponent, iOptions, iDotNetify, iHub) {
        var _this = this;
        this.onRouteEnter = function () { return true; };
        this.$vmId = iVMId;
        this.$component = iComponent;
        this.$options = iOptions || {};
        this.$vmArg = iOptions && iOptions["vmArg"];
        this.$headers = iOptions && iOptions["headers"];
        this.$exceptionHandler = iOptions && iOptions["exceptionHandler"];
        this.$requested = false;
        this.$loaded = false;
        this.$itemKey = {};
        this.$dotnetify = iDotNetify;
        this.$hub = iHub;
        var getState = iOptions && iOptions["getState"];
        var setState = iOptions && iOptions["setState"];
        getState =
            typeof getState === "function" ? getState : function () { return iComponent.state; };
        setState =
            typeof setState === "function"
                ? setState
                : function (state) { return iComponent.setState(state); };
        this.State = function (state) {
            return typeof state === "undefined" ? getState() : setState(state);
        };
        this.Props = function (prop) { return _this.$component.props && _this.$component.props[prop]; };
        var vmArg = this.Props("vmArg");
        if (vmArg)
            this.$vmArg = $.extend(this.$vmArg, vmArg);
        this.$getPlugins().map(function (plugin) {
            return typeof plugin["$inject"] == "function" ? plugin.$inject(_this) : null;
        });
    }
    DotnetifyVM.prototype.$destroy = function () {
        var _this = this;
        this.$getPlugins().map(function (plugin) {
            return typeof plugin["$destroy"] == "function"
                ? plugin.$destroy.apply(_this)
                : null;
        });
        if (this.$hub.isConnected) {
            try {
                this.$hub.disposeVM(this.$vmId);
            }
            catch (ex) {
                this.$dotnetify.controller.handleConnectionStateChanged("error", ex, this.$hub);
            }
        }
        delete this.$dotnetify.viewModels[this.$vmId];
    };
    DotnetifyVM.prototype.$dispatch = function (iValue) {
        if (this.$hub && this.$hub.isConnected) {
            var controller = this.$dotnetify.controller;
            try {
                this.$hub.updateVM(this.$vmId, iValue);
                if (controller.debug) {
                    console.log("[" + this.$vmId + "] sent> ");
                    console.log(iValue);
                    controller.debugFn && controller.debugFn(this.$vmId, "sent", iValue);
                }
            }
            catch (ex) {
                controller.handleConnectionStateChanged("error", ex, this.$hub);
            }
        }
    };
    DotnetifyVM.prototype.$dispatchListState = function (iValue) {
        var _this = this;
        var _loop_1 = function (listName) {
            var key = this_1.$itemKey[listName];
            if (!key) {
                console.error("[" + this_1.$vmId + "] missing item key for '" + listName + "'; decorate '" + listName + "' with an [ItemKey] attribute.");
                return { value: void 0 };
            }
            var item = iValue[listName];
            if (!item[key]) {
                console.error("[" + this_1.$vmId + "] couldn't dispatch data from '" + listName + "' due to missing property '" + key + "'.");
                console.error(item);
                return { value: void 0 };
            }
            Object.keys(item).forEach(function (prop) {
                if (prop != key) {
                    var state = {};
                    state[listName + ".$" + item[key] + "." + prop] = item[prop];
                    _this.$dispatch(state);
                }
            });
            this_1.$updateList(listName, item);
        };
        var this_1 = this;
        for (var listName in iValue) {
            var state_1 = _loop_1(listName);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    DotnetifyVM.prototype.$getPlugins = function () {
        var _this = this;
        return Object.keys(this.$dotnetify.plugins).map(function (id) { return _this.$dotnetify.plugins[id]; });
    };
    DotnetifyVM.prototype.$preProcess = function (iVMUpdate) {
        var vm = this;
        for (var prop in iVMUpdate) {
            var match = /(.*)_add/.exec(prop);
            if (match != null) {
                var listName = match[1];
                if (Array.isArray(this.State()[listName]))
                    vm.$addList(listName, iVMUpdate[prop]);
                else
                    console.error("unable to resolve " + prop);
                delete iVMUpdate[prop];
                continue;
            }
            var match = /(.*)_update/.exec(prop);
            if (match != null) {
                var listName = match[1];
                if (Array.isArray(this.State()[listName]))
                    vm.$updateList(listName, iVMUpdate[prop]);
                else
                    console.error("[" +
                        this.$vmId +
                        "] '" +
                        listName +
                        "' is not found or not an array.");
                delete iVMUpdate[prop];
                continue;
            }
            var match = /(.*)_remove/.exec(prop);
            if (match != null) {
                var listName = match[1];
                if (Array.isArray(this.State()[listName])) {
                    var key = this.$itemKey[listName];
                    if (key != null) {
                        if (Array.isArray(iVMUpdate[prop]))
                            vm.$removeList(listName, function (i) {
                                return iVMUpdate[prop].some(function (x) { return i[key] == x; });
                            });
                        else
                            vm.$removeList(listName, function (i) { return i[key] == iVMUpdate[prop]; });
                    }
                    else
                        console.error("[" + this.$vmId + "] missing item key for '" + listName + "'; decorate '" + listName + "' with an [ItemKey] attribute.");
                }
                else
                    console.error("[" + this.$vmId + "] '" + listName + "' is not found or not an array.");
                delete iVMUpdate[prop];
                continue;
            }
            var match = /(.*)_itemKey/.exec(prop);
            if (match != null) {
                var listName = match[1];
                var itemKey = {};
                itemKey[listName] = iVMUpdate[prop];
                vm.$setItemKey(itemKey);
                delete iVMUpdate[prop];
                continue;
            }
        }
    };
    DotnetifyVM.prototype.$request = function () {
        if (this.$hub.isConnected)
            this.$hub.requestVM(this.$vmId, {
                $vmArg: this.$vmArg,
                $headers: this.$headers
            });
        this.$requested = true;
    };
    DotnetifyVM.prototype.$update = function (iVMData) {
        var controller = this.$dotnetify.controller;
        if (controller.debug) {
            console.log("[" + this.$vmId + "] received> ");
            console.log(JSON.parse(iVMData));
            controller.debugFn &&
                controller.debugFn(this.$vmId, "received", JSON.parse(iVMData));
        }
        var vmData = JSON.parse(iVMData);
        this.$preProcess(vmData);
        var state = this.State();
        state = $.extend({}, state, vmData);
        this.State(state);
        if (!this.$loaded)
            this.$onLoad();
        else
            this.$onUpdate(vmData);
    };
    DotnetifyVM.prototype.$onLoad = function () {
        var _this = this;
        this.$getPlugins().map(function (plugin) {
            return typeof plugin["$ready"] == "function" ? plugin.$ready.apply(_this) : null;
        });
        this.$loaded = true;
    };
    DotnetifyVM.prototype.$onUpdate = function (vmData) {
        var _this = this;
        this.$getPlugins().map(function (plugin) {
            return typeof plugin["$update"] == "function"
                ? plugin.$update.apply(_this, [vmData])
                : null;
        });
    };
    DotnetifyVM.prototype.$setItemKey = function (iItemKey) {
        Object.assign(this.$itemKey, iItemKey);
    };
    DotnetifyVM.prototype.$addList = function (iListName, iNewItem) {
        var _this = this;
        var items = this.State()[iListName];
        if (Array.isArray(iNewItem) && !Array.isArray(items[0] || [])) {
            iNewItem.forEach(function (item) { return _this.$addList(iListName, item); });
            return;
        }
        var key = this.$itemKey[iListName];
        if (key != null) {
            if (!iNewItem.hasOwnProperty(key)) {
                console.error("[" + this.$vmId + "] couldn't add item to '" + iListName + "' due to missing property '" + key + "'.");
                return;
            }
            var match = this.State()[iListName].filter(function (i) {
                return i[key] == iNewItem[key];
            });
            if (match.length > 0) {
                console.error("[" + this.$vmId + "] couldn't add item to '" + iListName + "' because the key already exists.");
                return;
            }
        }
        items.push(iNewItem);
        var state = {};
        state[iListName] = items;
        this.State(state);
    };
    DotnetifyVM.prototype.$removeList = function (iListName, iFilter) {
        var state = {};
        state[iListName] = this.State()[iListName].filter(function (i) { return !iFilter(i); });
        this.State(state);
    };
    DotnetifyVM.prototype.$updateList = function (iListName, iNewItem) {
        var _this = this;
        var items = this.State()[iListName];
        if (Array.isArray(iNewItem) && !Array.isArray(items[0] || [])) {
            iNewItem.forEach(function (item) { return _this.$updateList(iListName, item); });
            return;
        }
        var key = this.$itemKey[iListName];
        if (key != null) {
            if (!iNewItem.hasOwnProperty(key)) {
                console.error("[" + this.$vmId + "] couldn't update item to '" + iListName + "' due to missing property '" + key + "'.");
                return;
            }
            var state = {};
            state[iListName] = items.map(function (i) {
                return i[key] == iNewItem[key] ? $.extend(i, iNewItem) : i;
            });
            this.State(state);
        }
        else
            console.error("[" + this.$vmId + "] missing item key for '" + iListName + "'; add '" + iListName + "_itemKey' property to the view model.");
    };
    return DotnetifyVM;
}());
exports.default = DotnetifyVM;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebApiHub = exports.DotNetifyHubWebApi = void 0;
var utils_1 = __webpack_require__(0);
var DotNetifyHubWebApi = (function () {
    function DotNetifyHubWebApi(iBaseUrl, iOnRequest) {
        this.url = "";
        this.mode = "webapi";
        this.debug = false;
        this.isConnected = false;
        this.isHubStarted = false;
        this.responseEvent = utils_1.createEventEmitter();
        this.reconnectedEvent = utils_1.createEventEmitter();
        this.connectedEvent = utils_1.createEventEmitter();
        this.connectionFailedEvent = utils_1.createEventEmitter();
        this.reconnectDelay = [];
        this._vmArgs = {};
        this.url = iBaseUrl || "";
        this.onRequest = iOnRequest;
    }
    DotNetifyHubWebApi.create = function (iBaseUrl, iOnRequest) {
        return new DotNetifyHubWebApi(iBaseUrl, iOnRequest);
    };
    DotNetifyHubWebApi.prototype.init = function () { };
    DotNetifyHubWebApi.prototype.stateChanged = function () { };
    DotNetifyHubWebApi.prototype.startHub = function () {
        this.isConnected = true;
        this.isHubStarted = true;
        this.connectedEvent.emit();
    };
    DotNetifyHubWebApi.prototype.requestVM = function (iVMId, iVMArgs) {
        var _this = this;
        var vmArgs = iVMArgs || {};
        var vmArgQuery = vmArgs.$vmArg
            ? "?vmarg=" + JSON.stringify(vmArgs.$vmArg)
            : "";
        var headers = vmArgs.$headers || {};
        this._vmArgs[iVMId] = vmArgs;
        var url = this.url + ("/api/dotnetify/vm/" + iVMId + vmArgQuery);
        utils_1.fetch("GET", url, null, function (request) {
            Object.keys(headers).forEach(function (key) {
                return request.setRequestHeader(key, headers[key]);
            });
            if (typeof _this.onRequest == "function")
                _this.onRequest(url, request);
        })
            .then(function (response) {
            _this.responseEvent.emit(iVMId, response);
        })
            .catch(function (request) { return console.error("[" + iVMId + "] Request failed", request); });
    };
    DotNetifyHubWebApi.prototype.updateVM = function (iVMId, iValue) {
        var _this = this;
        var vmArgs = this._vmArgs[iVMId] || {};
        var vmArgQuery = vmArgs.$vmArg
            ? "?vmarg=" + JSON.stringify(vmArgs.$vmArg)
            : "";
        var headers = vmArgs.$headers || {};
        var payload = typeof iValue == "object" ? JSON.stringify(iValue) : iValue;
        var url = this.url + ("/api/dotnetify/vm/" + iVMId + vmArgQuery);
        utils_1.fetch("POST", url, payload, function (request) {
            request.setRequestHeader("Content-Type", "application/json");
            Object.keys(headers).forEach(function (key) {
                return request.setRequestHeader(key, headers[key]);
            });
            if (typeof _this.onRequest == "function")
                _this.onRequest(url, request, payload);
        })
            .then(function (response) {
            _this.responseEvent.emit(iVMId, response);
        })
            .catch(function (request) { return console.error("[" + iVMId + "] Update failed", request); });
    };
    DotNetifyHubWebApi.prototype.disposeVM = function (iVMId) {
        var _this = this;
        delete this._vmArgs[iVMId];
        var url = this.url + ("/api/dotnetify/vm/" + iVMId);
        utils_1.fetch("DELETE", url, null, function (request) {
            if (typeof _this.onRequest == "function")
                _this.onRequest(url, request);
        }).catch(function (request) { return console.error("[" + iVMId + "] Dispose failed", request); });
    };
    return DotNetifyHubWebApi;
}());
exports.DotNetifyHubWebApi = DotNetifyHubWebApi;
var createWebApiHub = DotNetifyHubWebApi.create;
exports.createWebApiHub = createWebApiHub;
exports.default = DotNetifyHubWebApi.create();


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasLocalVM = exports.DotNetifyHubLocal = void 0;
var utils_1 = __webpack_require__(0);
var _window = window || global || {};
var normalize = function (iVMId) { return iVMId && iVMId.replace(/\./g, "_"); };
var hasLocalVM = function (iVMId) {
    var vmId = normalize(iVMId);
    var vm = _window[vmId];
    return typeof vm == "object" && typeof vm.onConnect == "function";
};
exports.hasLocalVM = hasLocalVM;
var DotNetifyHubLocal = (function () {
    function DotNetifyHubLocal() {
        this.url = null;
        this.mode = "local";
        this.debug = false;
        this.isConnected = false;
        this.isHubStarted = false;
        this.responseEvent = utils_1.createEventEmitter();
        this.reconnectedEvent = utils_1.createEventEmitter();
        this.connectedEvent = utils_1.createEventEmitter();
        this.connectionFailedEvent = utils_1.createEventEmitter();
        this.reconnectDelay = [];
    }
    DotNetifyHubLocal.prototype.init = function () { };
    DotNetifyHubLocal.prototype.stateChanged = function () { };
    DotNetifyHubLocal.prototype.startHub = function () {
        this.isConnected = true;
        this.isHubStarted = true;
        this.connectedEvent.emit();
    };
    DotNetifyHubLocal.prototype.requestVM = function (iVMId, iVMArgs) {
        var _this = this;
        var vmId = normalize(iVMId);
        var vm = _window[vmId];
        if (typeof vm === "object" && typeof vm.onConnect == "function") {
            if (this.debug)
                console.log("[" + iVMId + "] *** local mode ***");
            vm.$pushUpdate = function (update) {
                if (typeof update == "object")
                    update = JSON.stringify(update);
                setTimeout(function () { return _this.responseEvent.emit(iVMId, update); });
            };
            vm.$pushUpdate(vm.onConnect(iVMArgs) || {});
        }
    };
    DotNetifyHubLocal.prototype.updateVM = function (iVMId, iValue) {
        var _this = this;
        var vmId = normalize(iVMId);
        var vm = _window[vmId];
        if (typeof vm === "object" && typeof vm.onDispatch == "function") {
            var state_1 = vm.onDispatch(iValue);
            if (state_1) {
                if (typeof state_1 == "object")
                    state_1 = JSON.stringify(state_1);
                setTimeout(function () { return _this.responseEvent.emit(iVMId, state_1); });
            }
        }
    };
    DotNetifyHubLocal.prototype.disposeVM = function (iVMId) {
        var vmId = normalize(iVMId);
        var vm = _window[vmId];
        if (typeof vm === "object" && typeof vm.onDestroy == "function") {
            vm.onDestroy(iVMId);
        }
    };
    return DotNetifyHubLocal;
}());
exports.DotNetifyHubLocal = DotNetifyHubLocal;
exports.default = new DotNetifyHubLocal();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__15__;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

/**
* jQuery core object.
*
* Worker with jQuery deferred
*
* Code from: https://github.com/jquery/jquery/blob/master/src/core.js
*
*/

var jQuery = module.exports = {
	type: type
	, isArray: isArray
	, isFunction: isFunction
	, isPlainObject: isPlainObject
	, each: each
	, extend: extend
	, noop: function() {}
};

var toString = Object.prototype.toString;

var class2type = {};
// Populate the class2type map
"Boolean Number String Function Array Date RegExp Object".split(" ").forEach(function(name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});


function type( obj ) {
	return obj == null ?
		String( obj ) :
			class2type[ toString.call(obj) ] || "object";
}

function isFunction( obj ) {
	return jQuery.type(obj) === "function";
}

function isArray( obj ) {
	return jQuery.type(obj) === "array";
}

function each( object, callback, args ) {
	var name, i = 0,
	length = object.length,
	isObj = length === undefined || isFunction( object );

	if ( args ) {
		if ( isObj ) {
			for ( name in object ) {
				if ( callback.apply( object[ name ], args ) === false ) {
					break;
				}
			}
		} else {
			for ( ; i < length; ) {
				if ( callback.apply( object[ i++ ], args ) === false ) {
					break;
				}
			}
		}

		// A special, fast, case for the most common use of each
	} else {
		if ( isObj ) {
			for ( name in object ) {
				if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
					break;
				}
			}
		} else {
			for ( ; i < length; ) {
				if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
					break;
				}
			}
		}
	}

	return object;
}

function isPlainObject( obj ) {
	// Must be an Object.
	if ( !obj || jQuery.type(obj) !== "object" ) {
		return false;
	}
	return true;
}

function extend() {
	var options, name, src, copy, copyIsArray, clone,
	target = arguments[0] || {},
	i = 1,
	length = arguments.length,
	deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};




/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var jQuery = module.exports = __webpack_require__(16),
	core_rspace = /\s+/;
/**
* jQuery Callbacks
*
* Code from: https://github.com/jquery/jquery/blob/master/src/callbacks.js
*
*/


// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};



/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {


/*!
* jquery-deferred
* Copyright(c) 2011 Hidden <zzdhidden@gmail.com>
* MIT Licensed
*/

/**
* Library version.
*/

var jQuery = module.exports = __webpack_require__(17),
	core_slice = Array.prototype.slice;

/**
* jQuery deferred
*
* Code from: https://github.com/jquery/jquery/blob/master/src/deferred.js
* Doc: http://api.jquery.com/category/deferred-object/
*
*/

jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(18);

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.dotnetifyHubFactory = void 0;
var utils_1 = __webpack_require__(0);
var jQueryShim = __webpack_require__(3);
var signalRNetCore = __webpack_require__(15);
var $ = jQueryShim;
var _window = window || global || {};
var dotnetifyHubFactory = (function () {
    function dotnetifyHubFactory() {
    }
    dotnetifyHubFactory.create = function () {
        var dotnetifyHub = {
            version: "2.0.0",
            type: null,
            reconnectDelay: [2, 5, 10],
            reconnectRetry: null,
            _startInfo: null,
            _init: false,
            requestVM: function (iVMId, iOptions) {
                return dotnetifyHub.server.request_VM(iVMId, iOptions);
            },
            updateVM: function (iVMId, iValue) { return dotnetifyHub.server.update_VM(iVMId, iValue); },
            disposeVM: function (iVMId) { return dotnetifyHub.server.dispose_VM(iVMId); },
            responseEvent: utils_1.createEventEmitter(),
            reconnectedEvent: utils_1.createEventEmitter(),
            connectedEvent: utils_1.createEventEmitter(),
            connectionFailedEvent: utils_1.createEventEmitter(),
            get isHubStarted() {
                return !!this._startInfo;
            },
            startHub: function (hubOptions, doneHandler, failHandler, forceRestart) {
                var _this = this;
                var _doneHandler = function () {
                    if (typeof doneHandler == "function")
                        doneHandler();
                    _this.connectedEvent.emit();
                };
                var _failHandler = function (ex) {
                    if (typeof failHandler == "function")
                        failHandler();
                    _this.connectionFailedEvent.emit();
                    throw ex;
                };
                if (this._startInfo === null || forceRestart) {
                    try {
                        this._startInfo = this.start(hubOptions)
                            .done(_doneHandler)
                            .fail(_failHandler);
                    }
                    catch (err) {
                        this._startInfo = null;
                    }
                }
                else {
                    try {
                        this._startInfo.done(_doneHandler);
                    }
                    catch (err) {
                        this._startInfo = null;
                        return this.startHub(hubOptions, doneHandler, failHandler, forceRestart);
                    }
                }
            }
        };
        dotnetifyHub.init = function (iHubPath, iServerUrl, signalR) {
            if (dotnetifyHub._init)
                return;
            dotnetifyHub._init = true;
            signalR = signalR || _window.signalR || signalRNetCore;
            if (signalR && signalR.HubConnection) {
                dotnetifyHub.type = "netcore";
                Object.defineProperty(dotnetifyHub, "isConnected", {
                    get: function () {
                        return (dotnetifyHub._connection &&
                            dotnetifyHub._connection.connection.connectionState === 1);
                    }
                });
                dotnetifyHub = $.extend(dotnetifyHub, {
                    hubPath: iHubPath || "/dotnetify",
                    url: iServerUrl,
                    _connection: null,
                    _reconnectCount: 0,
                    _startDoneHandler: null,
                    _startFailHandler: null,
                    _disconnectedHandler: function () { },
                    _stateChangedHandler: function (iNewState) { },
                    _onDisconnected: function () {
                        dotnetifyHub._changeState(4);
                        dotnetifyHub._disconnectedHandler();
                    },
                    _changeState: function (iNewState) {
                        if (iNewState == 1)
                            dotnetifyHub._reconnectCount = 0;
                        var stateText = {
                            0: "connecting",
                            1: "connected",
                            2: "reconnecting",
                            4: "disconnected",
                            99: "terminated"
                        };
                        dotnetifyHub._stateChangedHandler(stateText[iNewState]);
                    },
                    _startConnection: function (iHubOptions, iTransportArray) {
                        var url = dotnetifyHub.url
                            ? dotnetifyHub.url + dotnetifyHub.hubPath
                            : dotnetifyHub.hubPath;
                        var hubOptions = {};
                        Object.keys(iHubOptions).forEach(function (key) {
                            hubOptions[key] = iHubOptions[key];
                        });
                        hubOptions.transport = iTransportArray.shift();
                        var hubConnectionBuilder = new signalR.HubConnectionBuilder().withUrl(url, hubOptions);
                        if (typeof hubOptions.connectionBuilder == "function")
                            hubConnectionBuilder = hubOptions.connectionBuilder(hubConnectionBuilder);
                        dotnetifyHub._connection = hubConnectionBuilder.build();
                        dotnetifyHub._connection.on("response_vm", dotnetifyHub.client.response_VM);
                        dotnetifyHub._connection.onclose(dotnetifyHub._onDisconnected);
                        var promise = dotnetifyHub._connection
                            .start()
                            .then(function () {
                            dotnetifyHub._changeState(1);
                        })
                            .catch(function () {
                            if (iTransportArray.length > 0)
                                dotnetifyHub._startConnection(iHubOptions, iTransportArray);
                            else
                                dotnetifyHub._onDisconnected();
                        });
                        if (typeof dotnetifyHub._startDoneHandler === "function")
                            promise
                                .then(dotnetifyHub._startDoneHandler)
                                .catch(dotnetifyHub._startFailHandler || function () { });
                        return promise;
                    },
                    start: function (iHubOptions) {
                        dotnetifyHub._startDoneHandler = null;
                        dotnetifyHub._startFailHandler = null;
                        var transport = [0];
                        var transportOptions = {
                            webSockets: 0,
                            serverSentEvents: 1,
                            longPolling: 2
                        };
                        if (iHubOptions && Array.isArray(iHubOptions.transport))
                            transport = iHubOptions.transport.map(function (arg) {
                                return transportOptions[arg];
                            });
                        var promise = dotnetifyHub._startConnection(iHubOptions, transport);
                        return {
                            done: function (iHandler) {
                                dotnetifyHub._startDoneHandler = iHandler;
                                promise.then(iHandler).catch(function (error) {
                                    throw error;
                                });
                                return this;
                            },
                            fail: function (iHandler) {
                                dotnetifyHub._startFailHandler = iHandler;
                                promise.catch(iHandler);
                                return this;
                            }
                        };
                    },
                    disconnected: function (iHandler) {
                        if (typeof iHandler === "function")
                            dotnetifyHub._disconnectedHandler = iHandler;
                    },
                    stateChanged: function (iHandler) {
                        if (typeof iHandler === "function")
                            dotnetifyHub._stateChangedHandler = iHandler;
                    },
                    reconnect: function (iStartHubFunc) {
                        if (typeof iStartHubFunc === "function") {
                            if (!dotnetifyHub.reconnectRetry ||
                                dotnetifyHub._reconnectCount < dotnetifyHub.reconnectRetry) {
                                var delay = dotnetifyHub._reconnectCount <
                                    dotnetifyHub.reconnectDelay.length
                                    ? dotnetifyHub.reconnectDelay[dotnetifyHub._reconnectCount]
                                    : dotnetifyHub.reconnectDelay[dotnetifyHub.reconnectDelay.length - 1];
                                dotnetifyHub._reconnectCount++;
                                setTimeout(function () {
                                    dotnetifyHub._changeState(2);
                                    iStartHubFunc();
                                }, delay * 1000);
                            }
                            else
                                dotnetifyHub._changeState(99);
                        }
                    },
                    client: {},
                    server: {
                        dispose_VM: function (iVMId) {
                            dotnetifyHub._connection.invoke("Dispose_VM", iVMId);
                        },
                        update_VM: function (iVMId, iValue) {
                            dotnetifyHub._connection.invoke("Update_VM", iVMId, iValue);
                        },
                        request_VM: function (iVMId, iArgs) {
                            dotnetifyHub._connection.invoke("Request_VM", iVMId, iArgs);
                        }
                    }
                });
            }
            else {
                dotnetifyHub.type = "netfx";
                if (_window.jQuery)
                    $ = _window.jQuery;
                (function ($) {
                    "use strict";
                    if (typeof $.signalR !== "function") {
                        throw new Error("SignalR: SignalR is not loaded. Please ensure jquery.signalR-x.js is referenced before ~/signalr/js.");
                    }
                    var signalR = $.signalR;
                    function makeProxyCallback(hub, callback) {
                        return function () {
                            callback.apply(hub, $.makeArray(arguments));
                        };
                    }
                    function registerHubProxies(instance, shouldSubscribe) {
                        var key, hub, memberKey, memberValue, subscriptionMethod;
                        for (key in instance) {
                            if (instance.hasOwnProperty(key)) {
                                hub = instance[key];
                                if (!hub.hubName) {
                                    continue;
                                }
                                if (shouldSubscribe) {
                                    subscriptionMethod = hub.on;
                                }
                                else {
                                    subscriptionMethod = hub.off;
                                }
                                for (memberKey in hub.client) {
                                    if (hub.client.hasOwnProperty(memberKey)) {
                                        memberValue = hub.client[memberKey];
                                        if (!$.isFunction(memberValue)) {
                                            continue;
                                        }
                                        subscriptionMethod.call(hub, memberKey, makeProxyCallback(hub, memberValue));
                                    }
                                }
                            }
                        }
                    }
                    $.hubConnection.prototype.createHubProxies = function () {
                        var proxies = {};
                        this.starting(function () {
                            registerHubProxies(proxies, true);
                            this._registerSubscribedHubs();
                        }).disconnected(function () {
                            registerHubProxies(proxies, false);
                        });
                        proxies["dotNetifyHub"] = this.createHubProxy("dotNetifyHub");
                        proxies["dotNetifyHub"].client = {};
                        proxies["dotNetifyHub"].server = {
                            dispose_VM: function (vmId) {
                                return proxies["dotNetifyHub"].invoke.apply(proxies["dotNetifyHub"], $.merge(["Dispose_VM"], $.makeArray(arguments)));
                            },
                            request_VM: function (vmId, vmArg) {
                                return proxies["dotNetifyHub"].invoke.apply(proxies["dotNetifyHub"], $.merge(["Request_VM"], $.makeArray(arguments)));
                            },
                            update_VM: function (vmId, vmData) {
                                return proxies["dotNetifyHub"].invoke.apply(proxies["dotNetifyHub"], $.merge(["Update_VM"], $.makeArray(arguments)));
                            }
                        };
                        return proxies;
                    };
                    signalR.hub = $.hubConnection(dotnetifyHub.hubPath, {
                        useDefaultPath: false
                    });
                    $.extend(signalR, signalR.hub.createHubProxies());
                })($);
                Object.defineProperty(dotnetifyHub, "state", {
                    get: function () {
                        return $.connection.hub.state;
                    },
                    set: function (val) {
                        $.connection.hub.state = val;
                    }
                });
                Object.defineProperty(dotnetifyHub, "client", {
                    get: function () {
                        return $.connection.dotNetifyHub.client;
                    }
                });
                Object.defineProperty(dotnetifyHub, "server", {
                    get: function () {
                        return $.connection.dotNetifyHub.server;
                    }
                });
                Object.defineProperty(dotnetifyHub, "isConnected", {
                    get: function () {
                        return ($.connection.hub.state == $.signalR.connectionState.connected);
                    }
                });
                dotnetifyHub = $.extend(dotnetifyHub, {
                    hubPath: iHubPath || "/signalr",
                    url: iServerUrl,
                    _reconnectCount: 0,
                    _stateChangedHandler: function (iNewState) { },
                    start: function (iHubOptions) {
                        if (dotnetifyHub.url)
                            $.connection.hub.url = dotnetifyHub.url;
                        var deferred;
                        if (iHubOptions)
                            deferred = $.connection.hub.start(iHubOptions);
                        else
                            deferred = $.connection.hub.start();
                        deferred.fail(function (error) {
                            if (error.source &&
                                error.source.message === "Error parsing negotiate response.")
                                console.warn("This client may be attempting to connect to an incompatible SignalR .NET Core server.");
                        });
                        return deferred;
                    },
                    disconnected: function (iHandler) {
                        return $.connection.hub.disconnected(iHandler);
                    },
                    stateChanged: function (iHandler) {
                        dotnetifyHub._stateChangedHandler = iHandler;
                        return $.connection.hub.stateChanged(function (state) {
                            if (state == 1)
                                dotnetifyHub._reconnectCount = 0;
                            var stateText = {
                                0: "connecting",
                                1: "connected",
                                2: "reconnecting",
                                4: "disconnected"
                            };
                            iHandler(stateText[state.newState]);
                        });
                    },
                    reconnect: function (iStartHubFunc) {
                        if (typeof iStartHubFunc === "function") {
                            if (!dotnetifyHub.reconnectRetry ||
                                dotnetifyHub._reconnectCount < dotnetifyHub.reconnectRetry) {
                                var delay = dotnetifyHub._reconnectCount <
                                    dotnetifyHub.reconnectDelay.length
                                    ? dotnetifyHub.reconnectDelay[dotnetifyHub._reconnectCount]
                                    : dotnetifyHub.reconnectDelay[dotnetifyHub.reconnectDelay.length - 1];
                                dotnetifyHub._reconnectCount++;
                                setTimeout(function () {
                                    dotnetifyHub._stateChangedHandler("reconnecting");
                                    iStartHubFunc();
                                }, delay * 1000);
                            }
                            else
                                dotnetifyHub._stateChangedHandler("terminated");
                        }
                    }
                });
            }
            dotnetifyHub.client.response_VM = function (iVMId, iVMData) {
                if (Array.isArray(iVMId)) {
                    iVMData = iVMId[1];
                    iVMId = iVMId[0];
                }
                var handled = dotnetifyHub.responseEvent.emit(iVMId, iVMData);
                if (!handled)
                    dotnetifyHub.server.dispose_VM(iVMId);
            };
            dotnetifyHub.disconnected(function () {
                dotnetifyHub._startInfo = null;
                dotnetifyHub.reconnect(function () {
                    dotnetifyHub.reconnectedEvent.emit();
                });
            });
        };
        return dotnetifyHub;
    };
    return dotnetifyHubFactory;
}());
exports.dotnetifyHubFactory = dotnetifyHubFactory;
exports.default = dotnetifyHubFactory.create();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dotnetify = void 0;
var dotnetify_hub_1 = __webpack_require__(21);
var dotnetify_hub_local_1 = __webpack_require__(14);
var dotnetify_hub_webapi_1 = __webpack_require__(13);
var Dotnetify = (function () {
    function Dotnetify() {
        this.react = null;
        this.vue = null;
        this.ko = null;
        this.hub = dotnetify_hub_1.default;
        this.hubOptions = {
            transport: ["webSockets", "longPolling"],
            connectionBuilder: function (builder) { return builder; }
        };
        this.hubPath = null;
        this.hubLib = null;
        this.debug = false;
        this.debugFn = null;
        this.connectionStateHandler = null;
        this.connectHandler = null;
        this._vmAccessors = [];
    }
    Object.defineProperty(Dotnetify.prototype, "hubServerUrl", {
        get: function () {
            return this.hub.url;
        },
        set: function (iUrl) {
            this.hub.url = iUrl;
            if (this.debug)
                console.log("SignalR: connecting to " + this.hubServerUrl);
            if (this.hub.isHubStarted)
                this.startHub(this.hub, true);
        },
        enumerable: false,
        configurable: true
    });
    Dotnetify.prototype.connect = function (iVMId, iOptions) {
        return _dotnetify.react.connect(iVMId, {}, iOptions);
    };
    Dotnetify.prototype.createHub = function (iHubServerUrl, iHubPath, iHubLib) {
        return this.initHub(dotnetify_hub_1.dotnetifyHubFactory.create(), iHubPath, iHubServerUrl, iHubLib);
    };
    Dotnetify.prototype.createWebApiHub = function (iBaseUrl, iRequestHandler) {
        return dotnetify_hub_webapi_1.createWebApiHub(iBaseUrl, iRequestHandler);
    };
    Dotnetify.prototype.initHub = function (iHub, iHubPath, iHubServerUrl, iHubLib) {
        var _this = this;
        var hub = iHub || this.hub;
        var hubPath = iHubPath || this.hubPath;
        var hubServerUrl = iHubServerUrl || this.hubServerUrl;
        var hubLib = iHubLib || this.hubLib;
        if (!hub.isHubStarted) {
            hub.init(hubPath, hubServerUrl, hubLib);
            hub.stateChanged(function (state) {
                return _this.handleConnectionStateChanged(state, null, hub);
            });
        }
        return hub;
    };
    Dotnetify.prototype.selectHub = function (vmConnectArgs) {
        vmConnectArgs = vmConnectArgs || {};
        vmConnectArgs.options = vmConnectArgs.options || {};
        var override = (typeof this.connectHandler == "function" &&
            this.connectHandler(vmConnectArgs)) ||
            {};
        if (!override.hub) {
            override.hub = dotnetify_hub_local_1.hasLocalVM(vmConnectArgs.vmId)
                ? dotnetify_hub_local_1.default
                : vmConnectArgs.options.webApi
                    ? dotnetify_hub_webapi_1.default
                    : this.initHub();
            override.hub.debug = this.debug;
        }
        return Object.assign(vmConnectArgs, override);
    };
    Dotnetify.prototype.startHub = function (iHub, iForceRestart) {
        var _this = this;
        var hub = iHub || this.hub;
        var doneHandler = function () { };
        var failHandler = function (ex) {
            return _this.handleConnectionStateChanged("error", ex, hub);
        };
        hub.startHub(this.hubOptions, doneHandler, failHandler, iForceRestart);
    };
    Dotnetify.prototype.addVMAccessor = function (iVMAccessor) {
        !this._vmAccessors.includes(iVMAccessor) &&
            this._vmAccessors.push(iVMAccessor);
    };
    Dotnetify.prototype.getViewModels = function () {
        return this._vmAccessors
            .reduce(function (prev, current) { return __spreadArrays(prev, current()); }, [])
            .filter(function (val, idx, self) {
            return self.indexOf(val) === idx;
        });
    };
    Dotnetify.prototype.handleConnectionStateChanged = function (iState, iException, iHub) {
        if (this.debug)
            console.log("SignalR: " + (iException ? iException.message : iState));
        if (typeof this.connectionStateHandler === "function")
            this.connectionStateHandler(iState, iException, iHub);
        else if (iException)
            console.error(iException);
    };
    Dotnetify.prototype.checkServerSideException = function (iVMId, iVMData, iExceptionHandler) {
        var vmData = JSON.parse(iVMData);
        if (vmData &&
            vmData.hasOwnProperty("ExceptionType") &&
            vmData.hasOwnProperty("Message")) {
            var exception = {
                name: vmData.ExceptionType,
                message: vmData.Message
            };
            if (typeof iExceptionHandler === "function") {
                iExceptionHandler(exception);
            }
            else {
                console.error("[" + iVMId + "] " + exception.name + ": " + exception.message);
                throw exception;
            }
        }
    };
    return Dotnetify;
}());
exports.Dotnetify = Dotnetify;
var _dotnetify = new Dotnetify();
exports.default = _dotnetify;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _dotnetifyVue = __webpack_require__(4);

var _dotnetifyVue2 = _interopRequireDefault(_dotnetifyVue);

__webpack_require__(11);

var _Scope = __webpack_require__(6);

var _Scope2 = _interopRequireDefault(_Scope);

var _directives = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_dotnetifyVue2.default.vue.Scope = _Scope2.default;
module.exports = Object.assign(_dotnetifyVue2.default, { Scope: _Scope2.default, registerDirectives: _directives.registerDirectives });

/***/ })
/******/ ]);
});
//# sourceMappingURL=dotnetify-vue.js.map